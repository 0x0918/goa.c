# 算法复杂度及渐进符号

## 一、算法复杂度

首先每个程序运行过程中，都要占用一定的计算机资源，比如内存，磁盘等，这些是空间，计算过程中需要判断，循环执行某些逻辑，周而反复，这些是时间。

那么一个算法有多好，多快，怎么衡量一个算法的好坏？所以，计算机科学在算法分析过程中，提出了算法复杂度理论，这套理论可以量化算法的效率，以此作为标准，方便我们能衡量到底选择哪一种算法。

复杂度有两个维度：时间和空间。

我们说，一个实现了某算法的程序，如果计算的速度越快，那么这个算法时间复杂度越低，如果占用的计算资源越少，那么空间复杂度越低。

我们要选择复杂度低的算法，衡量好空间和时间的消耗，选出适合特定场景的算法。

这两个复杂度维度的量化过程都是一样的，所以我们这里主要介绍时间复杂度。

## 二、算法规模

我们要计算公式 `1+2+3+...+100`，那么按照最直观的算法来写：

```go
package main

import "fmt"

func sum(n int) int {
	total := 0
	for i := 1; i <= n; i++ {
		total = total + i
	}
	return total
}

func main() {
	fmt.Println(sum(100))
}
```

当 `n = 10` 时就等于我们要计算的公式。这个算法要循环 `n-1` 次，当 `n` 很小时，计算很快，但当 `n` 无限大的时候，计算很慢。

所以，算法衡量要衡量的是在不同问题规模 `n` 下，算法的速度。

在这里，因为要循环计算 `n-1` 次，而当 `n` 无限大时，常数项基本忽略不计，所以这个算法的时间复杂度是 $\Omicron({n})$。

我们有另外一种计算方式：

```go
func sum2(n int) int {
	total := ((1 + n) * n) / 2
	return total
}
```

这次算法只需执行 1 次，所以这个算法的时间复杂度是 $\Omicron({1})$。可以看出，时间复杂度为$\Omicron({1})$的算法优于复杂度为$\Omicron({n})$的算法。

当然，还有指数级别的，对数级别的，阶乘级别的复杂度，如$\Omicron(n!)$，$\Omicron(a^n)$，$\Omicron(\log{n})$等。

算法的优先级排列如下，一般排在上面的要优于排在下面的：


1. 常数复杂度：$\Omicron({1})$
2. 对数复杂度：$\Omicron(\log{n})$
3. 一次方复杂度：$\Omicron({n})$
2. 一次方乘对数复杂度：$\Omicron(n\log{n})$
3. 乘方复杂度：$\Omicron({n^2})$，$\Omicron({n^3})$
4. 指数复杂度：$\Omicron(2^n)$
5. 阶乘复杂度：$\Omicron(n!)$
5. 无限大指数复杂度：$\Omicron(n^n)$


## 三、渐进符号

如何量化一个复杂度，到底有多复杂，计算机科学抽象出了几个复杂度渐进符号。渐进符号如下：

$\Omicron$，$\omicron$，$\Theta$，$\Omega$，$\omega$，分别读作：Omicron（大欧），omicron（小欧），Theta（西塔），Omega（大欧米伽），omega（小欧米伽）。

关系如下：

| 记号 | 含义 | 通俗理解
| ---- | ---- | ---- |
| $\Theta$ | 紧确界 | 相当于"=" |
| $\Omicron$ | 上界 | 相当于"<=" | 
| $\omicron$ | 非紧的上界 | 相当于"<" |
| $\Omega$ | 下界 | 相当于">=" |
| $\omega$ | 非紧的下界 | 相当于">" |


### 3.1.渐进紧确界符合：$\Theta$

https://blog.csdn.net/so_geili/article/details/53353593
https://blog.csdn.net/konglongdanfo1/article/details/85204312