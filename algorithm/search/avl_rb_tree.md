# AVL树和红黑树

二叉查找树的效率来源其二分查找的特征，时间复杂度在于二叉树的高度。

AVL树和红黑树都是相对平衡的二叉查找树，因为特殊的旋转平衡操作，树的高度被大大压低。它们查找效率较高，添加，删除，查找操作的平均时间复杂度都为 `log(n)`，经常在各种程序中被使用。

## 一、AVL树

AVL树是一颗自平衡的二叉查找树，1962年，发明者 `Adelson-Velsky` 和 `Landis` 发表了论文，以两个作者的名字命名了该数据结构。

1. 首先它是一颗二叉查找树。
2. 任意一个节点的左右子树最大高度差为1。

它的定义如此地简单，由于树特征定义，我们可以计算出其高度 `h` 的上界 `h<=1.44log(n)`，也就是最坏情况下，树的高度约等于 `1.44log(n)`。

>假设高度 `h` 的AVL树最少有 `f(h)` 个节点，因为左右子树的高度差不能大于1，根节点加上左右子树的节点为 `f(h) = 1 + f(h-1) + f(h-2)`，初始条件 `f(0)=0,f(1)=1`。
>
>经过数学的推算可以得出 h<=1.44log(n)，由于计算过程超纲了，在此不进行演算。

为了维持AVL树的特征，每次添加和删除元素都需要一次或多次旋转来调整树的平衡。调整的依据来自于二叉树节点的平衡因子：节点的左子树与右子树的高度差称为该节点的平衡因子，范围为 `[-1，0，1]`。

AVL树的数据结构如下：

```go
// AVL树
type AVLTree struct {
	Root *AVLTreeNode // 树根节点
}

// AVL节点
type AVLTreeNode struct {
	Value  int64                 // 值
	Times  int64                 // 值出现的次数
	Height int64                 // 该节点作为树根节点，树的高度，方便计算平衡因子
	Left   *AVLTreeNode // 左子树
	Right  *AVLTreeNode // 右字树
}

// 初始化一个AVL树
func NewAVLTree() *AVLTree {
	return new(AVLTree)
}
```

其中 `Height` 表示以该节点作为树的根节点，树的高度，方便计算平衡因子。

https://www.cnblogs.com/WindSun/p/11379670.html

https://www.jianshu.com/p/e150dc3ebe21

### 1.1. AVL树添加元素

添加元素前需要定位到元素的位置，然后查找节点的平衡因子是否在 `[-1，0，1]` 范围内，如果不在，需要进行旋转调整。

旋转有四种情况：

1. 左旋，转一次。
2. 右旋，转一次。
3. 先左后右旋，转两次。
4. 先右后左旋，转两次。

以下示意图摘自维基百科，阅读代码时可以参考。

![](../../picture/avl_tree.png)

在左子树上插上左儿子导致失衡，需要单右旋：

![](../../picture/right_avl_tree.png)

代码如下：

```go

```

单左旋：

![](../../picture/left_avl_tree.png)