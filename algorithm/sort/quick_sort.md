# 快速排序

快速排序算法是由英国计算机科学家 `Tony Hoare` 发明的， 该算法被发布在 `1961` 年的 `Communications of the ACM 月刊`。快速排序是对冒泡排序的一种改进，采用了一种分治的策略。

## 一、算法介绍

快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

步骤如下：

1. 先从数列中取出一个数作为基准数。一般取第一个数
2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3. 再对左右区间重复第二步，直到各区间只有一个数。

举一个例子：`5 9 1 6 8 14 6 49 25 4 6 3`。

```
一般取第一个数 5 作为基准，从它左边和最后一个数使用[]进行标志，

如果左边的数比基准数大，那么该数要往右边扔，也就是两个[]数交换，这样大于它的数就在右边了，然后右边[]数左移，否则左边[]数右移。

5 [9] 1 6 8 14 6 49 25 4 6 [3]  因为 9 > 5，两个[]交换位置后，右边[]左移
5 [3] 1 6 8 14 6 49 25 4 [6] 9  因为 3 !> 5，两个[]不需要交换，左边[]右移
5 3 [1] 6 8 14 6 49 25 4 [6] 9  因为 1 !> 5，两个[]不需要交换，左边[]右移
5 3 1 [6] 8 14 6 49 25 4 [6] 9  因为 6 > 5，两个[]交换位置后，右边[]左移
5 3 1 [6] 8 14 6 49 25 [4] 6 9  因为 6 > 5，两个[]交换位置后，右边[]左移
5 3 1 [4] 8 14 6 49 [25] 6 6 9  因为 4 !> 5，两个[]不需要交换，左边[]右移
5 3 1 4 [8] 14 6 49 [25] 6 6 9  因为 8 > 5，两个[]交换位置后，右边[]左移
5 3 1 4 [25] 14 6 [49] 8 6 6 9  因为 25 > 5，两个[]交换位置后，右边[]左移
5 3 1 4 [49] 14 [6] 25 8 6 6 9  因为 49 > 5，两个[]交换位置后，右边[]左移
5 3 1 4 [6] [14] 49 25 8 6 6 9  因为 6 > 5，两个[]交换位置后，右边[]左移
5 3 1 4 [14] 6 49 25 8 6 6 9  两个[]已经汇总，因为 14 > 5，所以 5 和[]之前的数 4 交换位置
第一轮切分结果：4 3 1 5 14 6 49 25 8 6 6 9  

现在第一轮快速排序已经将数列分成两个部分：

4 3 1 和 14 6 49 25 8 6 6 9

左边的数列小于 5，右边的数列大于 5。

使用递归分别对两个数列进行快速排序。
```


快速排序主要靠基准数进行切分，将数列分成两部分，一部分比基准数都小，一部分比基准数都大。

在最好情况下，每一轮排序都能平均切分，因为要遍历元素的次数只要：`n/2`，那么每一轮切分完成的时间复杂度是：`O(n)`。因为问题规模每次被折半，然后递归，也就是总的时间复杂度为： `T(n) = 2*T(n/2) + O(n)`。按照主定理分析，我们可以知道时间复杂度为：`O(nlogn)`，当然我们可以来具体计算一下：

```
我们来进行分析最好情况，假设每次划分的次数为 n/2.

T(n) = 2*T(n/2) + n/2
T(n/2) = 2*T(n/4) + n/4
T(n/4) = 2*T(n/8) + n/8
T(n/8) = 2*T(n/16) + n/16
...
T(4) = 2*T(2) + 4
T(2) = 2*T(1) + 2
T(1) = 1

进行合并也就是：

T(n) = 2*T(n/2) + n/2
     = 2^2*T(n/4)+ n/2 + n/2
     = 2^3*T(n/8) + n/2 + n/2 + n/2
     = 2^4*T(n/16) + n/2 + n/2 + n/2 + n/2
     = ...
     = 2^logn*T(1) + logn * n/2
     = 2^logn + 1/2*nlogn
     = n + 1/2*nlogn

因为当问题规模 n 趋于无穷大时 nlogn 比 n 大，所以 T(n) = O(nlogn)。
```

最差的情况下，每次都不能平均地切分，每次切分都因为基准数是最大的或者最小的，不能分成两个数列，这样时间复杂度变为了 `T(n) = T(n-1) + O(n)`，按照主定理计算可以知道时间复杂度为：`O(n^2)`，我们可以计算：

```
我们来进行分析最差情况，假设每次划分的次数为 n.

T(n) = T(n-1) + n
     = T(n-2) + n-1 + n
     = T(n-3) + n-2 + n-1 + n
     = ...
     = T(1) + 2 +3 + ... + n-2 + n-1 + n
     = O(n^2)
```

一般情况下，基准数切分不均衡的情况很少，所以快速排序平均时间复杂度为：`O(nlogn)`。

因为递归栈的影响，递归的栈开辟的层数范围在 `logn~n`，所以递归栈的空间复杂度为：`O(logn)~log(n)`。但如果使用尾递归进行优化，那么每次递归之后栈空间被释放，那么递归栈的空间复杂度为 `O(1)`，可以见下面算法优化。

如何避免切分不均匀发生，有几种方法：

1. 每次进行快速排序切分时，先将数列随机打乱，再进行快速排序，这样随机加了个震荡，减少不均衡的情况。
2. 每次取数列头部，中部，尾部三个数，取三个数的中位数进行切分。

方法 1 相对好，而方法 2 引入了额外的比较操作。

一般情况下，大量数据规模的数列，出现最差情况的情形较少，根据熵的概念，数量越多越无序，所以我们不需要担忧最差情况的发生。

对比之前介绍的排序算法，快速排序是综合最好的，在平均情况下时间复杂度都是 `O(nlogn)`，这也是为什么大部分编程语言库都使用它的原因。

快速排序是不稳定的，因为切分过程中，相同值的元素可能发生位置变化。

## 二、算法实现

```go
package main

import "fmt"

func QuickSort(array []int, begin, end int) {
	var i, j int
	if begin < end {
		i = begin + 1 // 将array[begin]作为基准数，因此从array[begin+1]开始与基准数比较！
		j = end       // array[end]是数组的最后一位

		// 没重合之前
		for i < j {
			if array[i] > array[begin] {
				array[i], array[j] = array[j], array[i] // 交换
				j--
			} else {
				i++
			}
		}

		/* 跳出while循环后，i = j。
		 * 此时数组被分割成两个部分  -->  array[begin+1] ~ array[i-1] < array[begin]
		 *                        -->  array[i+1] ~ array[end] > array[begin]
		 * 这个时候将数组array分成两个部分，再将array[i]与array[begin]进行比较，决定array[i]的位置。
		 * 最后将array[i]与array[begin]交换，进行两个分割部分的排序！以此类推，直到最后i = j不满足条件就退出！
		 */
		if array[i] >= array[begin] { // 这里必须要取等“>=”，否则数组元素由相同的值组成时，会出现错误！
			i--
		}

		array[begin], array[i] = array[i], array[begin]
		QuickSort(array, begin, i)
		QuickSort(array, j, end)
	}
}

func main() {
	list := []int{5}
	QuickSort(list, 0, len(list)-1)
	fmt.Println(list)

	list1 := []int{5, 9}
	QuickSort(list1, 0, len(list1)-1)
	fmt.Println(list1)

	list2 := []int{5, 9, 1}
	QuickSort(list2, 0, len(list2)-1)
	fmt.Println(list2)

	list3 := []int{5, 9, 1, 6, 8, 14, 6, 49, 25, 4, 6, 3}
	QuickSort(list3, 0, len(list3)-1)
	fmt.Println(list3)
}
```

输出：

```go
[5]
[5 9]
[1 5 9]
[1 3 4 5 6 6 6 8 9 14 25 49]
```

快速排序，每一次切分都维护两个指针，进行推进，最后将数列分成两部分。

## 三、算法改进

快速排序可以继续进行算法改进。

1. 在小规模数组的情况下，选择排序的效率最好，当快速排序递归部分进入小数组范围，可以切换成选择排序。
2. 排序数列可能存在大量重复值，使用三向切分快速排序，将数组分成三部分，大于基准数，等于基准数，小于基准数，这个时候需要维护三个指针。
3. 使用尾递归减少栈空间占用。

### 3.1 改进：小规模数组使用选择排序

```go
// 改进：当数组规模小时使用选择排序

func SelectSort(list []int) {
	n := len(list)
	// 进行 N-1 轮迭代
	for i := 0; i < n-1; i++ {
		// 每次从第 i 位开始，找到最小的元素
		min := list[i] // 最小数
		minIndex := i  // 最小数的下标
		for j := i + 1; j < n; j++ {
			if list[j] < min {
				// 如果找到的数比上次的还小，那么最小的数变为它
				min = list[j]
				minIndex = j
			}
		}

		// 这一轮找到的最小数的下标不等于最开始的下标，交换元素
		if i != minIndex {
			list[i], list[minIndex] = list[minIndex], list[i]
		}
	}
}

func QuickSort1(array []int, begin, end int) {
	// 当数组小于 4 时使用选择排序
	if end-begin < 4 {
		SelectSort(array[begin : end+1])
		return
	}

	var i, j int
	if begin < end {
		i = begin + 1 // 将array[begin]作为基准数，因此从array[begin+1]开始与基准数比较！
		j = end       // array[end]是数组的最后一位

		// 没重合之前
		for i < j {
			if array[i] > array[begin] {
				array[i], array[j] = array[j], array[i] // 交换
				j--
			} else {
				i++
			}
		}

		/* 跳出while循环后，i = j。
		 * 此时数组被分割成两个部分  -->  array[begin+1] ~ array[i-1] < array[begin]
		 *                        -->  array[i+1] ~ array[end] > array[begin]
		 * 这个时候将数组array分成两个部分，再将array[i]与array[begin]进行比较，决定array[i]的位置。
		 * 最后将array[i]与array[begin]交换，进行两个分割部分的排序！以此类推，直到最后i = j不满足条件就退出！
		 */
		if array[i] >= array[begin] { // 这里必须要取等“>=”，否则数组元素由相同的值组成时，会出现错误！
			i--
		}

		array[begin], array[i] = array[i], array[begin]
		QuickSort1(array, begin, i)
		QuickSort1(array, j, end)
	}
}
```

我们只是将 `end-begin < 4` 的递归部分换成了选择排序。

### 3.2 改进：三向切分

```go
// 三切分的快速排序
func QuickSort2(array []int, begin, end int) {
	var lt, gt, i int // 维持三个下标
	if begin < end {
		lt = begin        // 左下标从第一位开始
		gt = end          // 右下标是数组的最后一位
		i = begin + 1     // 中间下标，从第二位开始
		v := array[begin] // 基准数

		// 以中间坐标为准
		for i <= gt {
			if array[i] > v { // 大于基准数，那么交换，右指针左移
				array[i], array[gt] = array[gt], array[i]
				gt--
			} else if array[i] < v { // 小于基准数，那么交换，左指针右移
				array[i], array[lt] = array[lt], array[i]
				lt++
				i++
			} else {
				i++
			}
		}

		// 从lt到gt的部分是三切分的中间数列
		QuickSort2(array, begin, lt-1)
		QuickSort2(array, gt+1, end)
	}
}
```

演示：

```
数列：4 8 2 4 4 4 7 9，基准数为 4

[4] [8] 2 4 4 4 7 [9]  从中间[]开始：8 > 4，中右[]进行交换，右边[]左移
[4] [9] 2 4 4 4 [7] 8  从中间[]开始：9 > 4，中右[]进行交换，右边[]左移
[4] [7] 2 4 4 [4] 9 8  从中间[]开始：7 > 4，中右[]进行交换，右边[]左移
[4] [4] 2 4 [4] 7 9 8  从中间[]开始：4 == 4，不需要交换，中间[]右移
[4] 4 [2] 4 [4] 7 9 8  从中间[]开始：2 < 4，中左[]需要交换，中间和左边[]右移
2 [4] 4 [4] [4] 7 9 8  从中间[]开始：4 == 4，不需要交换，中间[]右移
2 [4] 4 4 [[4]] 7 9 8  从中间[]开始：4 == 4，不需要交换，中间[]右移，因为已经重叠了
第一轮结果：2 4 4 4 4 7 9 8

分成三个数列：

2
4 4 4 4
7 9 8

接着对第一个和最后一个数列进行递归即可。
```

三切分，把小于基准数的扔到左边，大于基准数的扔到右边，相同的元素会进行聚集。

如果存在大量重复元素，排序速度将极大提高，将会是线性时间，因为相同的元素将会聚集在中间，这些元素不再进入下一个递归迭代。

### 3.3 改进：尾递归优化